class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        //可以用一个map将所有数字存起来，然后从小到大开始遍历这些连续整数
        //发现的第一个在map中不存在的整数就是答案，但是题目要求在常数
        //级别的额外空间内完成，所以不能直接使用该思路，需要另辟蹊径
        //我们发现nums就可以当作一个map来使用，但是这个map中的一个位置
        //可能会被覆盖但是他待会还要使用，所以我们在设置一个数字是否出现时
        //需要不破坏原本存在这个位置上的数字，我们可以将它取反当负数存下来
        //然后在遍历一遍这个数组如果一个位置上的数字仍然大于零说明他就是
        //第一个缺失的数字
        int n = nums.size();
        for(int i = 0; i < n; ++i) {
            //负数没有任何意义将他设置为n + 1(也就是可能缺失的最大数字)
            //如果n + 1之间有数字缺失这个替换逻辑没有问题，因为最后的
            //循环会提前退出，如果真的是n + 1缺失了那也没关系，应为它属于
            //edge case并不会对map产生什么影响只有最后一个循环执行完毕
            //才能判断是否是n + 1缺失了
            if(nums[i] <= 0) {
                nums[i] = n + 1;
            }
        }

        for(int i = 0; i < n; ++i) {
            //nums能充当一个能放n个数的map,前提是从0开始
            //按照上面的思路我们将nums的nums[i] - 1位设置为负数
            //表示nums[i]出现过，这里为了防止之前的数字已经将
            //nums[i]设置为了负数，我们保险起见用abs将nums[i]转一下
            int index = abs(nums[i]) - 1;

            //大于n不用管
            if(index < n) {
                //将nums的第nums[i]-1位设置为他的相反数以表示nums[i]出现过
                //为了防止有多个nums[i]数字存在又将改为翻转为正数，我们用
                //abs将nums[index]包起来
                nums[index] = -abs(nums[index]);
            }
        }

        for(int i = 0; i < n; ++i) {
            //如果一个位置依然是正数说明他是缺失的
            if(nums[i] > 0) return i + 1;
        }

        //所有数字都没有缺失，那就算n + 1缺失
        return n + 1;
    }
};